
# HG changeset patch
# User Geoff Lankow <geoff@darktrojan.net>
# Date 1767579590 -46800
# Node ID 0345b619be9be9024aee72e1cebc5e6bdc018e67
# Parent  f2d26a0d4d8da4adaea179e091f8bcf91642575b
Bug 2008485 - Avoid jank in CalDAV sync handler. r=mkmelin

Differential Revision: https://phabricator.services.mozilla.com/D277820

diff --git a/calendar/providers/caldav/modules/CalDavRequestHandlers.sys.mjs b/calendar/providers/caldav/modules/CalDavRequestHandlers.sys.mjs
--- a/calendar/providers/caldav/modules/CalDavRequestHandlers.sys.mjs
+++ b/calendar/providers/caldav/modules/CalDavRequestHandlers.sys.mjs
@@ -396,16 +396,17 @@ export class CalDavWebDavSyncHandler ext
   newSyncToken = null;
   changeLogListener = null;
   logXML = "";
   isInPropStat = false;
   unhandledErrors = 0;
   itemsReported = null;
   itemsNeedFetching = null;
   additionalSyncNeeded = false;
+  shouldYieldEventLoop = 0;
 
   QueryInterface = ChromeUtils.generateQI(["nsIRequestObserver", "nsIStreamListener"]);
 
   async doWebDAVSync() {
     if (this.calendar.mDisabledByDavError) {
       // check if maybe our calendar has become available
       this.calendar.checkDavResourceType(this.changeLogListener);
       return;
@@ -743,16 +744,23 @@ export class CalDavWebDavSyncHandler ext
             "CalDAV: Unhandled response element, status: " +
               resp.status +
               ", href: " +
               resp.href +
               " contenttype:" +
               resp.getcontenttype
           );
         }
+
+        // Every 25 items yield the event loop to avoid blocking the main thread
+        // and appearing unresponsive.
+        if (++this.shouldYieldEventLoop == 25) {
+          await new Promise(resolve => setTimeout(resolve));
+          this.shouldYieldEventLoop = 0;
+        }
         break;
       }
       case "sync-token": {
         this.newSyncToken = this.currentResponse[this.tag];
         break;
       }
       case "propstat": {
         this.isInPropStat = false;

