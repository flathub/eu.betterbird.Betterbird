
# HG changeset patch
# User welpy-cw <h.w.forms@arcor.de>
# Date 1758019096 -3600
# Node ID 98f11bc525c4eac19d383aa90f5699083186f5ad
# Parent  e98fece66617b8ab65b12ef604f4629914933245
Bug 1988558 - Adapt cookie manager to changes from bug 1839918. r=mkmelin


Also backport fixes from the (by now deprecated) Firefox version of cookies.js for

- Deleting multiple cookies deletes wrong ones and/or not all selected (Bug 388079) and
- Missing column sort indicator in Preferences ▸ Privacy ▸ Show Cookies... (Bug 416554).

Additionally update the internal representation of hosts when they are removed in order
to avoid errors afterwards.

Differential Revision: https://phabricator.services.mozilla.com/D264824

diff --git a/mail/components/preferences/cookies.js b/mail/components/preferences/cookies.js
--- a/mail/components/preferences/cookies.js
+++ b/mail/components/preferences/cookies.js
@@ -21,34 +21,32 @@ window.addEventListener("unload", () => 
 var gCookiesWindow = {
   _hosts: {},
   _hostOrder: [],
   _tree: null,
   _bundle: null,
 
   init() {
     Services.obs.addObserver(this, "cookie-changed");
-    Services.obs.addObserver(this, "perm-changed");
 
     this._bundle = document.getElementById("bundlePreferences");
     this._tree = document.getElementById("cookiesList");
 
     this._populateList(true);
 
     document.getElementById("filter").focus();
 
     if (!Services.prefs.getBoolPref("privacy.userContext.enabled")) {
       document.getElementById("userContext").hidden = true;
       document.getElementById("userContextLabel").hidden = true;
     }
   },
 
   uninit() {
     Services.obs.removeObserver(this, "cookie-changed");
-    Services.obs.removeObserver(this, "perm-changed");
   },
 
   _populateList(aInitialLoad) {
     this._loadCookies();
     this._tree.view = this._view;
     if (aInitialLoad) {
       this.sort("rawHost");
     }
@@ -78,46 +76,53 @@ var gCookiesWindow = {
       aCookieA.path == aCookieB.path &&
       ChromeUtils.isOriginAttributesEqual(
         aCookieA.originAttributes,
         aCookieB.originAttributes
       )
     );
   },
 
-  observe(aCookie, aTopic, aData) {
-    if (aTopic != "cookie-changed") {
+  observe(subject, topic) {
+    if (topic != "cookie-changed") {
       return;
     }
 
-    if (aCookie instanceof Ci.nsICookie) {
-      var strippedHost = this._makeStrippedHost(aCookie.host);
-      if (aData == "changed") {
-        this._handleCookieChanged(aCookie, strippedHost);
-      } else if (aData == "added") {
-        this._handleCookieAdded(aCookie, strippedHost);
-      }
-    } else if (aData == "cleared") {
+    const notification = subject.QueryInterface(Ci.nsICookieNotification);
+
+    const { ALL_COOKIES_CLEARED, COOKIE_CHANGED, COOKIE_ADDED } =
+      Ci.nsICookieNotification;
+
+    if (notification.action == ALL_COOKIES_CLEARED) {
       this._hosts = {};
       this._hostOrder = [];
 
-      var oldRowCount = this._view._rowCount;
+      const oldRowCount = this._view._rowCount;
       this._view._rowCount = 0;
       this._tree.rowCountChanged(0, -oldRowCount);
       this._view.selection.clearSelection();
-    } else if (aData == "reload") {
-      // first, clear any existing entries
-      this.observe(aCookie, aTopic, "cleared");
+      return;
+    }
 
-      // then, reload the list
-      this._populateList(false);
+    if (![COOKIE_CHANGED, COOKIE_ADDED].includes(notification.action)) {
+      return;
     }
 
-    // We don't yet handle aData == "deleted" - it's a less common case
-    // and is rather complicated as selection tracking is difficult
+    const cookie = notification.cookie.QueryInterface(Ci.nsICookie);
+    const strippedHost = this._makeStrippedHost(cookie.host);
+    switch (notification.action) {
+      case COOKIE_CHANGED:
+        this._handleCookieChanged(cookie, strippedHost);
+        break;
+      case COOKIE_ADDED:
+        this._handleCookieAdded(cookie, strippedHost);
+        break;
+      // We don't yet handle the COOKIE_DELETED notification - it's a less common
+      // case and is rather complicated as selection tracking is difficult
+    }
   },
 
   _handleCookieChanged(changedCookie, strippedHost) {
     var rowIndex = 0;
     var cookieItem = null;
     if (!this._view._filtered) {
       for (var i = 0; i < this._hostOrder.length; ++i) {
         // (var host in this._hosts) {
@@ -292,17 +297,23 @@ var gCookiesWindow = {
       }
 
       const item = this._getItemAtIndex(aIndex);
       if (!item) {
         return;
       }
       this._invalidateCache(aIndex - 1);
       if (item.container) {
-        gCookiesWindow._hosts[item.rawHost] = null;
+        delete gCookiesWindow._hosts[item.rawHost];
+        const idx = gCookiesWindow._hostOrder.findIndex(
+          el => el == item.rawHost
+        );
+        if (idx >= 0) {
+          gCookiesWindow._hostOrder.splice(idx, 1);
+        }
       } else {
         const parent = this._getItemAtIndex(item.parentIndex);
         for (let i = 0; i < parent.cookies.length; ++i) {
           var cookie = parent.cookies[i];
           if (
             item.rawHost == cookie.rawHost &&
             item.name == cookie.name &&
             item.path == cookie.path &&
@@ -762,22 +773,25 @@ var gCookiesWindow = {
       }
       this._view._rowCount += rowCountImpact;
       tbo.rowCountChanged(ci, rowCountImpact);
       if (invalidateRow != -1) {
         tbo.invalidateRow(invalidateRow);
       }
     } else {
       var rangeCount = seln.getRangeCount();
-      for (var i = 0; i < rangeCount; ++i) {
+      // Traverse backwards through selections to avoid messing
+      // up the indices when they are deleted.
+      // See bug 388079.
+      for (let i = rangeCount - 1; i >= 0; --i) {
         var min = {};
         var max = {};
         seln.getRangeAt(i, min, max);
         nextSelected = min.value;
-        for (var j = min.value; j <= max.value; ++j) {
+        for (let j = min.value; j <= max.value; ++j) {
           deleteItems.push(this._view._getItemAtIndex(j));
           if (!this._view.hasNextSibling(-1, max.value)) {
             --nextSelected;
           }
         }
         var delta = max.value - min.value + 1;
         this._view._removeItemAtIndex(min.value, delta);
         rowCountImpact = -1 * delta;
@@ -847,16 +861,28 @@ var gCookiesWindow = {
     // Sort the Filtered List, if in Filtered mode
     if (this._view._filtered) {
       this._view._filterSet.sort(sortByProperty);
       if (!ascending) {
         this._view._filterSet.reverse();
       }
     }
 
+    // Adjust the sort indicator.
+    const domainCol = document.getElementById("domainCol");
+    const nameCol = document.getElementById("nameCol");
+    const sortOrderString = ascending ? "ascending" : "descending";
+    if (aProperty == "rawHost") {
+      domainCol.setAttribute("sortDirection", sortOrderString);
+      nameCol.removeAttribute("sortDirection");
+    } else {
+      nameCol.setAttribute("sortDirection", sortOrderString);
+      domainCol.removeAttribute("sortDirection");
+    }
+
     this._view._invalidateCache(0);
     this._view.selection.clearSelection();
     this._view.selection.select(0);
     this._tree.invalidate();
     this._tree.ensureRowIsVisible(0);
 
     this._lastSortAscending = ascending;
     this._lastSortProperty = aProperty;

